<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cuack Game | CTF Muliplayer</title>
    <link rel="icon" href="Modelos/small-duck.svg" />
    <link rel="stylesheet" href="inicio.css" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
      }
      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
      .split {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        display: flex;
      }
      .split > div {
        width: 100%;
        height: 100%;
      }
      #view1 {
        border-right-color: black;
        border-right: 2px;
      }
    </style>
  </head>
  <body>
    <audio autoplay>
      <source
        src="Club Penguin - Pizza Parlor Theme (Charlie's Here) [FULL High Quality].mp3"
        type="audio/mpeg"
      />
    </audio>
    <canvas id="c"></canvas>
    <div class="split">
      <div id="view1" tabindex="1"></div>
      <div id="view3" tabindex="3"></div>
    </div>

    <div id="PopupFinal" style="display: none">
      <div class="finalJuego">
        <div id="textoFinal">
          <h3 class="centered">Game Over</h3>
          <h1>Jugador 1: <span id="puntosJ1"></span></h1>
          <h1>Jugador 2: <span id="puntosJ2"></span></h1>
          <h1>Ganador: <span id="ganador"></span></h1>
        </div>
        <div id="botonFinal">
          <a href="index.html"><button class="salirFinal">Salir</button></a>
        </div>
      </div>
    </div>

    <div id="Popup" style="display: none">
      <div class="pausamenu">
        <h3>Pausa</h3>
        <div class="botones">
          <!--<a href=""><button>Ajustes</button></a>-->
          <button onclick="regresarPopup()">Regresar</button>
          <a href="index.html"
            ><button class="salir">Salir del juego</button></a
          >
        </div>
      </div>
    </div>

    <script>
      function regresarPopup() {
        document.getElementById("Popup").style.display = "none";
      }
    </script>

    <script type="module">
      import * as THREE from "./Modules/three.module.js";
      import { OrbitControls } from "./Modules/OrbitControls.js";
      import { OBJLoader } from "./Modules/OBJLoader.js";
      import { MTLLoader } from "./Modules/MtLLoader.js";

      function main() {
        const canvas = document.querySelector("#c");
        const view1Elem = document.querySelector("#view1");
        const view3Elem = document.querySelector("#view3");
        const renderer = new THREE.WebGLRenderer({ canvas });

        const fov = 60;
        const aspect = 2;

        let duck1object = new THREE.Group();
        let duck2object = new THREE.Group();

        let bandera1object = new THREE.Group();
        let bandera2object = new THREE.Group();

        //BoundingBoxLoader-----------------
        const duck1BB = new THREE.Box3();
        const duck2BB = new THREE.Box3();

        const bandera1BB = new THREE.Box3();
        const bandera2BB = new THREE.Box3();

        const goalJ2BB = new THREE.Box3(
          new THREE.Vector3(-130, 0, -0.5),
          new THREE.Vector3(130, 10, 0.5)
        );

        const goalJ1BB = new THREE.Box3(
          new THREE.Vector3(-130, 0, -0.5),
          new THREE.Vector3(130, 10, 0.5)
        );

        let cajaMorada;
        let cajaVerde;
        let cajaGris;

        let cajaMoradaBB;
        let cajaVerdeBB;
        let cajaGrisBB;

        let posicionCaja1;
        let posicionCaja2;
        let posicionCaja3;

        const loader = new OBJLoader();
        const textureLoader = new THREE.TextureLoader();

        const keys1 = {
          forward: false,
          backward: false,
          left: false,
          right: false,
        };

        const keys2 = {
          forward: false,
          backward: false,
          left: false,
          right: false,
        };

        //Camara1
        const camera = new THREE.PerspectiveCamera(fov, aspect);
        camera.position.set(0, 30, -165);
        const cameraHelper = new THREE.CameraHelper(camera);

        //Camara 2
        const camera3 = new THREE.PerspectiveCamera(fov, aspect);
        camera3.position.set(0, 30, 165);
        const camera3Helper = new THREE.CameraHelper(camera3);

        // const controls3 = new OrbitControls(camera3, view3Elem);
        // controls3.target.set(0, 5, 0);
        // controls3.update();

        //Escena
        const scene = new THREE.Scene();
        scene.background = new THREE.Color("#34495E");

        scene.add(cameraHelper);
        scene.add(camera3Helper);

        //Luces
        {
          //Luz Direccional
          const color = 0xffffff;
          const intensity = 1;
          const light = new THREE.DirectionalLight(color, intensity);
          light.position.set(0, 10, 0);
          light.target.position.set(-5, 0, 0);
          scene.add(light);
          scene.add(light.target);

          //Luz Hemisferica
          const hemisphereLight = new THREE.HemisphereLight(
            0xffffbb,
            0x080820,
            1
          );
          scene.add(hemisphereLight);
        }

        //-----------Carga de Modelos---------------------------------------------------------------------

        //Plano de Agua
        {
          const planeGeometry = new THREE.PlaneGeometry(50, 50);
          const planeMaterial = new THREE.MeshStandardMaterial({
            color: "#0C5E58",
          });
          const plane = new THREE.Mesh(planeGeometry, planeMaterial);
          plane.position.set(0, -0.5, 0);
          plane.scale.set(5, 10);
          plane.receiveShadow = true;
          plane.rotateX(-Math.PI / 2);
          scene.add(plane);
        }
        //Base / Cubo de J2     NO TOCAR
        {
          const cube1Geometry = new THREE.BoxGeometry(233, 1, 1);
          const cube1Material = new THREE.MeshBasicMaterial({ color: "red" });
          const cube1 = new THREE.Mesh(cube1Geometry, cube1Material);
          cube1.position.z = 150;
          scene.add(cube1);

          goalJ2BB.translate(new THREE.Vector3(0, 0, 150));

          // const goalJ2BBHelper = new THREE.Box3Helper(goalJ2BB, 0xff0000);
          // scene.add(goalJ2BBHelper);
        }
        //Base / Cubo de J1     NO TOCAR
        {
          const cube1Geometry = new THREE.BoxGeometry(233, 1, 1);
          const cube1Material = new THREE.MeshBasicMaterial({
            color: 0xffff00,
          });
          const cube1 = new THREE.Mesh(cube1Geometry, cube1Material);
          cube1.position.z = -150;
          scene.add(cube1);

          goalJ1BB.translate(new THREE.Vector3(0, 0, -150));

          // const goalJ1BBHelper = new THREE.Box3Helper(goalJ1BB, 0xffff00);
          // scene.add(goalJ1BBHelper);
        }
        //Modelo PATO 1 J1      NO TOCAR
        {
          const duck1Texture = textureLoader.load("./Modelos/PATO/PATO_UV.png");
          loader.load(
            "./Modelos/PATO/PATO.obj",
            function (object) {
              duck1object = object;
              const duck1Mat = new THREE.MeshBasicMaterial({
                map: duck1Texture,
              });
              duck1object.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = duck1Mat;
                }
              });

              duck1object.position.set(0, 0, -160);
              duck1object.scale.set(2, 2, 2);

              scene.add(duck1object);

              //Duck1BoundingBox
              duck1BB.setFromObject(duck1object);
              // const duck1BBHelper = new THREE.Box3Helper(duck1BB, 0xffff00);
              // scene.add(duck1BBHelper);
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded,Duck1");
            },
            function (error) {
              console.log("An error happened,Duck1");
            }
          );
        }
        //Modelo PATO 2 J2      NO TOCAR
        {
          const duck2Texture = textureLoader.load(
            "./Modelos/PATO2/PATO_ROJO.png"
          );
          loader.load(
            "./Modelos/PATO2/PATO.obj",
            function (object) {
              duck2object = object;
              const duck2Mat = new THREE.MeshBasicMaterial({
                map: duck2Texture,
              });
              duck2object.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = duck2Mat;
                }
              });

              duck2object.position.set(0, 0, 160);
              duck2object.rotation.y += 3.14159;
              duck2object.scale.set(2, 2, 2);

              scene.add(duck2object);

              //Duck2BoundingBox
              duck2BB.setFromObject(duck2object);
              // const duck2BBHelper = new THREE.Box3Helper(duck2BB, "red");
              // scene.add(duck2BBHelper);
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded,Duck2");
            },
            function (error) {
              console.log("An error happened,Duck2");
            }
          );
        }
        //Modelo de Item
        {
          const materialMorado = new THREE.MeshBasicMaterial({
            color: 0x800080,
          });
          const materialVerde = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
          });
          const materialGris = new THREE.MeshBasicMaterial({ color: 0x808080 });

          const geometriaCaja = new THREE.BoxGeometry(4, 4, 4);

          cajaMorada = new THREE.Mesh(geometriaCaja, materialMorado);
          cajaVerde = new THREE.Mesh(geometriaCaja, materialVerde);
          cajaGris = new THREE.Mesh(geometriaCaja, materialGris);

          const posicionesDisponibles = [
            new THREE.Vector3(76, 2, -80),
            new THREE.Vector3(49, 2, 21),
            new THREE.Vector3(-70, 2, 78),
          ];

          function obtenerPosicionAleatoria(ocupadas) {
            const posicionesLibres = posicionesDisponibles.filter(
              (pos) => !ocupadas.some((ocupada) => pos.equals(ocupada))
            );

            if (posicionesLibres.length > 0) {
              const posicionSeleccionada =
                posicionesLibres[
                  Math.floor(Math.random() * posicionesLibres.length)
                ];
              return posicionSeleccionada;
            } else {
              return null;
            }
          }

          posicionCaja1 = obtenerPosicionAleatoria([]);
          posicionCaja2 = obtenerPosicionAleatoria([posicionCaja1]);
          posicionCaja3 = obtenerPosicionAleatoria([
            posicionCaja1,
            posicionCaja2,
          ]);

          cajaMorada.position.copy(posicionCaja1);
          cajaVerde.position.copy(posicionCaja2);
          cajaGris.position.copy(posicionCaja3);

          cajaMoradaBB = new THREE.Box3().setFromObject(cajaMorada);
          cajaVerdeBB = new THREE.Box3().setFromObject(cajaVerde);
          cajaGrisBB = new THREE.Box3().setFromObject(cajaGris);

          scene.add(cajaMorada);
          scene.add(cajaVerde);
          scene.add(cajaGris);
        }
        //SWAMP FLOOR
        {
          const SwampTexture = textureLoader.load(
            "./Modelos/SWAMP_FLOOR/SAMP_FLOOR_UV.png"
          );
          loader.load(
            "./Modelos/SWAMP_FLOOR/SAMP_FLOOR.obj",
            function (SAMP) {
              const SwampMaterial = new THREE.MeshBasicMaterial({
                map: SwampTexture,
              });
              SwampMaterial.castShadow = true;
              SAMP.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = SwampMaterial;
                }
              });
              SAMP.position.set(0, 15, 0);
              SAMP.scale.set(40, 40, 40);
              scene.add(SAMP);
            },
            function (xhr) {
              console.log(
                (xhr.loaded / xhr.total) * 100 + "% loaded Swamp Floor"
              );
            },
            function (error) {
              console.log("An error happened, Swamp Floor");
            }
          );
        }
        //SWAMP SKY
        {
          const skyTexture = textureLoader.load(
            "./Modelos/SWAMP_SKY/SWAMP_SKY_2.png"
          );
          loader.load(
            "./Modelos/SWAMP_SKY/SWAMP_SKY.obj",
            function (sky) {
              const skyMaterial = new THREE.MeshBasicMaterial({
                map: skyTexture,
              });
              skyMaterial.castShadow = true;
              sky.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = skyMaterial;
                }
              });
              sky.position.set(0, 15, 0);
              sky.scale.set(40, 40, 40);
              scene.add(sky);
            },
            function (xhr) {
              console.log(
                (xhr.loaded / xhr.total) * 100 + "% loaded Swamp Sky"
              );
            },
            function (error) {
              console.log("An error happened, Swamp Sky");
            }
          );
        }
        // LOG
        {
          const Logtexture = textureLoader.load("./Modelos/LOG/LOG_UV.png");
          loader.load(
            "./Modelos/LOG/LOG.obj",
            function (Log) {
              //Log = object;
              const Logmaterial = new THREE.MeshBasicMaterial({
                map: Logtexture,
              });
              Logmaterial.castShadow = true;
              Log.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = Logmaterial;
                }
              });
              Log.position.set(0, -2, 0);
              Log.scale.set(5, 5, 5);
              Log.rotateY(Math.PI / 2);
              scene.add(Log);
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded, Log");
            },
            function (error) {
              console.log("An error happened, Log");
            }
          );
        }
        //Roca
        {
          const RockTextura = textureLoader.load("./Modelos/ROCK/ROCK_UV.png");
          loader.load(
            "./Modelos/ROCK/ROCK.obj",
            function (Rock) {
              const Rockmaterial = new THREE.MeshBasicMaterial({
                map: RockTextura,
              });
              Rockmaterial.castShadow = true;
              Rock.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = Rockmaterial;
                }
              });
              Rock.position.set(60, 0, 70);
              Rock.scale.set(15, 15, 15);
              Rock.rotation.y -= THREE.MathUtils.degToRad(45);

              // Enable shadows for the Rock object
              Rock.castShadow = true;

              scene.add(Rock);
            },

            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded. Rock");
            },
            function (error) {
              console.log("An error happened. Rock");
            }
          );
        }
        //Tortuga 1
        {
          const turtTextura = textureLoader.load(
            "./Modelos/TURTLE/TURTLE_UV.png"
          );
          loader.load(
            "./Modelos/TURTLE/TURTLE.obj",
            function (Turtle) {
              const materialTurtle = new THREE.MeshBasicMaterial({
                map: turtTextura,
              });
              materialTurtle.castShadow = true;
              Turtle.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = materialTurtle;
                }
              });
              Turtle.position.set(70, 0, -40);
              Turtle.scale.set(15, 15, 15);
              Turtle.rotateY(Math.PI / 3);

              // Enable shadows for the Turtle object
              Turtle.castShadow = true;

              scene.add(Turtle);
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded, TURTLE");
            },
            function (error) {
              console.log("An error happened, Turtle");
            }
          );
        }
        // TORTUGA 2
        {
          const turtTextura = textureLoader.load(
            "./Modelos/TURTLE/TURTLE_UV.png"
          );
          loader.load(
            "./Modelos/TURTLE/TURTLE.obj",
            function (Turtle) {
              const materialTurtle = new THREE.MeshBasicMaterial({
                map: turtTextura,
              });
              materialTurtle.castShadow = true;
              Turtle.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = materialTurtle;
                }
              });
              Turtle.position.set(-70, 0, 30);
              Turtle.scale.set(15, 15, 15);
              Turtle.rotateY(Math.PI);

              // Enable shadows for the Turtle object
              Turtle.castShadow = true;

              scene.add(Turtle);
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded, TURTLE");
            },
            function (error) {
              console.log("An error happened, Turtle");
            }
          );
        }
        //TORTUGA 3
        {
          const turtTextura = textureLoader.load(
            "./Modelos/TURTLE/TURTLE_UV.png"
          );
          loader.load(
            "./Modelos/TURTLE/TURTLE.obj",
            function (Turtle) {
              const materialTurtle = new THREE.MeshBasicMaterial({
                map: turtTextura,
              });
              materialTurtle.castShadow = true;
              Turtle.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = materialTurtle;
                }
              });
              Turtle.position.set(35, 0, -78);
              Turtle.scale.set(15, 15, 15);
              Turtle.rotateY(-Math.PI / 2);

              // Enable shadows for the Turtle object
              Turtle.castShadow = true;

              scene.add(Turtle);
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded, TURTLE");
            },
            function (error) {
              console.log("An error happened, Turtle");
            }
          );
        }
        //Cocodrilo
        {
          const crocTexture = textureLoader.load("./Modelos/CROC/CROC_UV.png");
          loader.load(
            "./Modelos/CROC/CROCODILE.obj",
            function (Croc) {
              const crocMat = new THREE.MeshBasicMaterial({
                map: crocTexture,
              });
              crocMat.castShadow = true;
              Croc.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = crocMat;
                }
              });

              Croc.position.set(-40, 5, -90);
              Croc.scale.set(15, 15, 15);
              Croc.rotateY(Math.PI / 3);
              scene.add(Croc);
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded,Croc");
            },
            function (error) {
              console.log("An error happened,Croc");
            }
          );
        }
        //Bandera J1NO TOCAR
        {
          const bandera1Text = textureLoader.load(
            "./Modelos/BANDERA_R/Bandera_Y_UV.png"
          );
          loader.load(
            "./Modelos/BANDERA_R/BANDERA.obj",
            function (object) {
              bandera1object = object;
              const ban1Mat = new THREE.MeshBasicMaterial({
                map: bandera1Text,
              });
              bandera1object.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = ban1Mat;
                }
              });
              bandera1object.position.set(0, 0, -180);
              bandera1object.scale.set(5, 5, 5);
              bandera1object.rotateY(Math.PI / 2);
              scene.add(bandera1object);

              //Bandera1 BB
              bandera1BB.setFromObject(bandera1object);
              // const bandera1BBHelper = new THREE.Box3Helper(
              //   bandera1BB,
              //   0xffff00
              // );
              // scene.add(bandera1BBHelper);
            },
            function (xhr) {
              console.log(
                (xhr.loaded / xhr.total) * 100 + "% loaded,Bandera J1"
              );
            },
            function (error) {
              console.log("An error happened,Bandera J1");
            }
          );
        }
        //Bandera J2    NO TOCAR
        {
          const bandera2Text = textureLoader.load(
            "./Modelos/BANDERA_R/Bandera_R_UV.png"
          );
          loader.load(
            "./Modelos/BANDERA_R/BANDERA.obj",
            function (object) {
              bandera2object = object;
              const ban2Mat = new THREE.MeshBasicMaterial({
                map: bandera2Text,
              });
              bandera2object.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                  child.material = ban2Mat;
                }
              });
              bandera2object.position.set(0, 0, 180);
              bandera2object.scale.set(5, 5, 5);
              bandera2object.rotateY(Math.PI / 2);
              scene.add(bandera2object);
              //Bandera2 BB
              bandera2BB.setFromObject(bandera2object);
              // const bandera2BBHelper = new THREE.Box3Helper(bandera2BB, "red");
              // scene.add(bandera2BBHelper);
            },
            function (xhr) {
              console.log(
                (xhr.loaded / xhr.total) * 100 + "% loaded,Bandera J2"
              );
            },
            function (error) {
              console.log("An error happened,Bandera J2");
            }
          );
        }

        //---Logica de movimiento------------------------------------------------------------------------------

        document.addEventListener("keydown", (e) => _onKeyDown(e), false);
        document.addEventListener("keyup", (e) => _onKeyUp(e), false);

        function _onKeyDown(event) {
          switch (event.keyCode) {
            case 87: // w
              keys1.forward = true;
              break;
            case 65: // a
              keys1.left = true;
              break;
            case 83: // s
              keys1.backward = true;
              break;
            case 68: // d
              keys1.right = true;
              break;

            case 80: //p
              console.log("Pausa ", pausa);
              break;

            //Arrow Key Up
            case 38:
              keys2.forward = true;
              break;
            //Arrow Key Down
            case 40:
              keys2.backward = true;
            //Arrow Key Right
            case 39:
              keys2.right = true;
              break;
            //Arrow Key Left
            case 37:
              keys2.left = true;
              break;
          }
        }

        function _onKeyUp(event) {
          switch (event.keyCode) {
            case 87: // w
              keys1.forward = false;
              break;
            case 65: // a
              keys1.left = false;
              break;
            case 83: // s
              keys1.backward = false;
              break;
            case 68: // d
              keys1.right = false;
              break;

            case 80: // p
              document.getElementById("Popup").style.display = "block";
              break;

            //Arrow Key Up
            case 38:
              keys2.forward = false;
              break;
            //Arrow Key Down
            case 40:
              keys2.backward = false;
            //Arrow Key Right
            case 39:
              keys2.right = false;
              break;
            //Arrow Key Left
            case 37:
              keys2.left = false;
              break;
          }
        }

        function movement(_target, timeInSeconds, keys, accel) {
          if (!_target) {
            return;
          }
          let decceleration = new THREE.Vector3(-0.0005, -0.0001, -5.0);
          let acceleration = new THREE.Vector3(1, 0.15, accel);
          let velocity = new THREE.Vector3(0, 0, 0);

          const frameDecceleration = new THREE.Vector3(
            velocity.x * decceleration.x,
            velocity.y * decceleration.y,
            velocity.z * decceleration.z
          );
          frameDecceleration.multiplyScalar(timeInSeconds);
          frameDecceleration.z =
            Math.sign(frameDecceleration.z) *
            Math.min(Math.abs(frameDecceleration.z), Math.abs(velocity.z));

          velocity.add(frameDecceleration);
          const controlObject = _target;
          const _Q = new THREE.Quaternion();
          const _A = new THREE.Vector3();
          const _R = controlObject.quaternion.clone();

          const acc = acceleration.clone();

          if (keys.forward) {
            velocity.z += acc.z * timeInSeconds;
          }
          if (keys.backward) {
            velocity.z -= acc.z * timeInSeconds;
          }
          if (keys.left) {
            _A.set(0, 1, 0);
            _Q.setFromAxisAngle(
              _A,
              4.0 * Math.PI * timeInSeconds * acceleration.y
            );
            _R.multiply(_Q);
          }
          if (keys.right) {
            _A.set(0, 1, 0);
            _Q.setFromAxisAngle(
              _A,
              4.0 * -Math.PI * timeInSeconds * acceleration.y
            );
            _R.multiply(_Q);
          }
          controlObject.quaternion.copy(_R);

          const oldPosition = new THREE.Vector3();
          oldPosition.copy(controlObject.position);

          const forward = new THREE.Vector3(0, 0, 1);
          forward.applyQuaternion(controlObject.quaternion);
          forward.normalize();

          const sideways = new THREE.Vector3(1, 0, 0);
          sideways.applyQuaternion(controlObject.quaternion);
          sideways.normalize();

          sideways.multiplyScalar(velocity.x * timeInSeconds);
          forward.multiplyScalar(velocity.z * timeInSeconds);

          controlObject.position.add(forward);
          controlObject.position.add(sideways);

          oldPosition.copy(controlObject.position);
        }

        //---Logica de Juego-----------------------------------------------------------------------------------

        let puntosJ1 = 0;
        let puntosJ2 = 0;

        let bandera1Captured = false;
        let bandera2Captured = false;

        let flag2followsDuck1 = false;
        let flag1followsDuck2 = false;

        let canMove = true;

        let slowEffect = false;
        let fastEffect = false;

        const flag1Originpos = new THREE.Vector3(0, 0, -180);
        const flag2Originpos = new THREE.Vector3(0, 0, 180);

        let duracionPartida = 120;
        let tiempoRestante = duracionPartida; //Tiempo en segundos
        let temporizador;

        let cajasrespawn = 0;

        cajaMorada.name = "cajaMorada";
        cajaVerde.name = "cajaVerde";
        cajaGris.name = "cajaGris";

        let MBoxStatus = true;
        let VBoxStatus = true;
        let GBoxStatus = true;

        const nrmlAccel = 3000;
        const fastAccel = 5000;
        const slowAccel = 1000;

        let duck1Accel = nrmlAccel;
        let duck2Accel = nrmlAccel;

        let fastDuck = 0;
        let slowDuck = 0;

        let fastTick = 0;
        let slowTick = 0;

        function slowTarget(duckAccel, id) {
          let newDuckAccel = duckAccel;

          newDuckAccel = slowAccel;
          slowDuck = id;
          slowEffect = true;

          return newDuckAccel;
        }

        function fastTarget(duckAccel, id) {
          let newDuckAccel = duckAccel;

          newDuckAccel = fastAccel;
          fastDuck = id;
          fastEffect = true;

          return newDuckAccel;
        }

        function resetAccel(duckAccel) {
          duckAccel = nrmlAccel;

          if (fastEffect) {
            fastEffect = false;
            fastDuck = 0;
          }

          if (slowEffect) {
            slowEffect = false;
            slowDuck = 0;
          }

          return duckAccel;
        }

        function slowEffectTimer() {
          console.log(slowTick);
          if (slowEffect) {
            if (slowTick >= 10) {
              duck1Accel = slowDuck === 1 ? resetAccel(duck1Accel) : duck1Accel;
              duck2Accel = slowDuck === 2 ? resetAccel(duck2Accel) : duck2Accel;

              slowEffect = false;
              slowTick = 0;
            } else {
              slowTick++;
            }
          }
        }

        function fastEffectTimer() {
          console.log(fastTick);
          if (fastEffect) {
            if (fastTick >= 20) {
              duck1Accel = fastDuck === 1 ? resetAccel(duck1Accel) : duck1Accel;
              duck2Accel = fastDuck === 2 ? resetAccel(duck2Accel) : duck2Accel;

              fastEffect = false;
              fastTick = 0;
            } else {
              fastTick++;
            }
          }
        }

        function iniciarTemporizador() {
          temporizador = setInterval(function () {
            tiempoRestante--;

            slowEffectTimer();
            fastEffectTimer();

            if (cajasrespawn >= 30) {
              resetBox();
              cajasrespawn = 0;
            } else {
              cajasrespawn++;
            }
          }, 1000);
        }

        function moveBox(box, flag) {
          if (box.name == "cajaMorada" && MBoxStatus) {
            cajaMorada.position.set(300, 0, 300);
            cajaMoradaBB.setFromObject(cajaMorada);
            MBoxStatus = false;
          }
          if (box.name == "cajaVerde" && VBoxStatus) {
            cajaVerde.position.set(300, 0, 300);
            cajaVerdeBB.setFromObject(cajaVerde);
            VBoxStatus = false;
          }
          if (box.name == "cajaGris" && GBoxStatus) {
            cajaGris.position.set(300, 0, 300);
            cajaGrisBB.setFromObject(cajaGris);
            GBoxStatus = false;
          }
        }

        function resetBox() {
          console.log("Se reiniciaron las cajas");

          VBoxStatus = true;
          GBoxStatus = true;
          MBoxStatus = true;

          cajaMorada.position.copy(posicionCaja1);
          cajaVerde.position.copy(posicionCaja2);
          cajaGris.position.copy(posicionCaja3);
          cajaMoradaBB.setFromObject(cajaMorada);
          cajaVerdeBB.setFromObject(cajaVerde);
          cajaGrisBB.setFromObject(cajaGris);
        }

        function formatTime(tiempoSegundos) {
          let minutos = Math.floor(tiempoSegundos / 60);
          let segundos = tiempoSegundos % 60;
          return `${minutos}:${segundos < 10 ? "0" : ""}${segundos}`;
        }

        function followDuck(flagObject, duckObject) {
          flagObject.position.copy(duckObject.position);
          flagObject.rotation.copy(duckObject.rotation);
          flagObject.rotation.y += Math.PI;
        }

        function resetFlagPos(flagObject, originalPosition) {
          flagObject.position.copy(originalPosition);
          flagObject.rotation.set(0, 0, 0);
          flagObject.rotateY(Math.PI / 2);
        }

        function checkCollisions() {
          //Colision PATO AMARILLO con BANDERA ROJA
          if (duck1BB.intersectsBox(bandera2BB) && !bandera2Captured) {
            bandera2Captured = true;
            console.log("La bandera roja esta en posesion del equipo amarillo");
            flag2followsDuck1 = true;
          }
          //Colision PATO ROJO con BANDERA AMARILLA
          if (duck2BB.intersectsBox(bandera1BB) && !bandera1Captured) {
            bandera1Captured = true;
            console.log("La bandera amarilla esta en posesion del equipo rojo");
            flag1followsDuck2 = true;
          }

          //Colision PATO AMARILLO con BASE AMARILLA
          if (duck1BB.intersectsBox(goalJ1BB) && bandera2Captured) {
            bandera2Captured = false;
            puntosJ1++;
            console.log(
              "La bandera roja ha sido capturada! \n Puntuacion: Amarillo= ",
              puntosJ1,
              ", Rojo= ",
              puntosJ2,
              " ."
            );
            flag2followsDuck1 = false;
            resetFlagPos(bandera2object, flag2Originpos);
          }

          //Colision PATO ROJO CON BASE ROJA
          if (duck2BB.intersectsBox(goalJ2BB) && bandera1Captured) {
            bandera1Captured = false;
            puntosJ2++;
            console.log(
              "La bandera amarilla ha sido capturada! \n Puntuacion: Amarillo= ",
              puntosJ1,
              ", Rojo= ",
              puntosJ2,
              " ."
            );
            flag1followsDuck2 = false;
            resetFlagPos(bandera1object, flag1Originpos);
          }

          if (flag1followsDuck2) {
            followDuck(bandera1object, duck2object);
          }

          if (flag2followsDuck1) {
            followDuck(bandera2object, duck1object);
          }
          //PATO AMARILLO ITEM MORADO
          if (duck1BB.intersectsBox(cajaMoradaBB)) {
            console.log("El equipo amarillo obtuvo el punto extra!");
            moveBox(cajaMorada, MBoxStatus);
            puntosJ1++;
          }
          //PATO AMARILLO ITEM VERDE
          if (duck1BB.intersectsBox(cajaVerdeBB)) {
            console.log("Power up para el equipo Amarillo");
            moveBox(cajaVerde, VBoxStatus);
            duck1Accel = fastTarget(duck1Accel, 1);
          }
          //PATO AMARILLO ITEM GRIS
          if (duck1BB.intersectsBox(cajaGrisBB)) {
            console.log("Desventaja para el equipo Rojo");
            moveBox(cajaGris, GBoxStatus);
            duck2Accel = slowTarget(duck2Accel, 2);
          }
          //PATO ROJO ITEM MORADO
          if (duck2BB.intersectsBox(cajaMoradaBB)) {
            console.log("El equipo rojo obtuvo el punto extra!");
            moveBox(cajaMorada, MBoxStatus);
            puntosJ2++;
          }
          //PATO ROJO ITEM VERDE
          if (duck2BB.intersectsBox(cajaVerdeBB)) {
            console.log("Power up para el equipo Rojo");
            moveBox(cajaVerde, VBoxStatus);
            duck2Accel = fastTarget(duck2Accel, 2);
          }
          //PATO ROJO ITEM GRIS
          if (duck2BB.intersectsBox(cajaGrisBB)) {
            console.log("Desventaja para el equipo Amarillo");
            moveBox(cajaGris, GBoxStatus);
            duck1Accel = slowTarget(duck1Accel, 1);
          }
        }

        let msg;

        function printWinner() {
          if (puntosJ1 > puntosJ2) {
            msg = "¡AMARILLO HA GANADO!";
          }
          if (puntosJ2 > puntosJ1) {
            msg = "¡ROJO HA GANADO!";
          }
          if (puntosJ1 == puntosJ2) {
            msg = "¡EMPATE!";
          }
        }

        function gameLogic() {
          if (tiempoRestante >= 0) {
            console.log("Tiempo restante: " + formatTime(tiempoRestante));
            checkCollisions();
          } else {
            clearInterval(temporizador);
            temporizador = undefined;
            canMove = false;
            printWinner();
            // Asignar valores a los elementos HTML
            document.getElementById("puntosJ1").innerText = puntosJ1;
            document.getElementById("puntosJ2").innerText = puntosJ2;
            document.getElementById("ganador").innerText = msg;
            document.getElementById("PopupFinal").style.display = "block";
          }
        }

        iniciarTemporizador();

        //---Logica de Render----------------------------------------------------------------------------------
        function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
            renderer.setSize(width, height, false);
          }
          return needResize;
        }

        function setScissorForElement(elem) {
          const canvasRect = canvas.getBoundingClientRect();
          const elemRect = elem.getBoundingClientRect();

          // compute a canvas relative rectangle
          const right =
            Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
          const left = Math.max(0, elemRect.left - canvasRect.left);
          const bottom =
            Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
          const top = Math.max(0, elemRect.top - canvasRect.top);

          const width = Math.min(canvasRect.width, right - left);
          const height = Math.min(canvasRect.height, bottom - top);

          // setup the scissor to only render to that part of the canvas
          const positiveYUpBottom = canvasRect.height - bottom;
          renderer.setScissor(left, positiveYUpBottom, width, height);
          renderer.setViewport(left, positiveYUpBottom, width, height);

          // return the aspect
          return width / height;
        }

        function updateCamera(camera, duck) {
          const duckDirection = new THREE.Vector3(0, 0, 1);

          duckDirection.applyQuaternion(duck.quaternion);
          duckDirection.normalize();

          const cameraDistance = 20;

          const cameraHeight = 10;

          const cameraPosition = duck.position
            .clone()
            .addScaledVector(duckDirection, -cameraDistance)
            .add(new THREE.Vector3(0, cameraHeight, 0));
          camera.position.copy(cameraPosition);
          camera.lookAt(duck.position);
        }

        function girarItems() {
          let intervalo = 0.1;
          cajaMorada.rotation.y += intervalo;
          cajaVerde.rotation.y += intervalo;
          cajaGris.rotation.y -= intervalo / 2;
        }

        //Funcion principal de renderizado-------------------------
        function render() {
          resizeRendererToDisplaySize(renderer);

          // turn on the scissor
          renderer.setScissorTest(true);

          girarItems();

          // render the original view
          {
            const aspect = setScissorForElement(view1Elem);

            // adjust the camera for this aspect
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            cameraHelper.update();

            // don't draw the camera helper in the original view
            cameraHelper.visible = false;
            camera3Helper.visible = false;

            scene.background.set("#34495E");

            // render
            renderer.render(scene, camera);
          }

          // render the offset view
          {
            const aspect = setScissorForElement(view3Elem);

            // adjust the camera for this aspect
            camera3.aspect = aspect;
            camera3.updateProjectionMatrix();
            camera3Helper.update();

            // don't draw the camera helper in the original view
            cameraHelper.visible = false;
            camera3Helper.visible = false;

            scene.background.set("#34495E");

            // render
            renderer.render(scene, camera3);
          }

          if (duck1object) {
            updateCamera(camera, duck1object);
          }

          if (duck2object) {
            updateCamera(camera3, duck2object);
          }

          if (canMove) {
            movement(duck1object, 0.016, keys1, duck1Accel);
            movement(duck2object, 0.016, keys2, duck2Accel);
          }

          //Actualizar los movimientos de las cajas
          duck1BB.setFromObject(duck1object);
          duck2BB.setFromObject(duck2object);

          gameLogic();

          requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
      }
      main();
    </script>
  </body>
</html>
